package ziptrack.zip.core;

import java.util.HashSet;
import java.util.HashMap;

import ziptrack.grammar.Symbol;

public abstract class SymbolZip<
	T extends SymbolZip<T, U> & NonTerminalZip<T, U>,
	U extends SymbolZip<T, U> & TerminalZip
> extends Symbol {
    protected String name;

	// Given a thread t or lock l, this data structure stores the
	// number of occurrences of events involving t or l in the
	// trace generated by this symbol.
	public HashMap<Integer, Integer> threadOrLockCount;
	// Given a variable x, this data structure stores the
	// number of occurrences of events that write to x in the
	// trace generated by this symbol.
	public HashMap<Integer, Integer> writeCount;
	// Given a variable x and thread t, this data structure stores the
	// number of occurrences of events performed by t that read from x in the
	// trace generated by this symbol.
	public HashMap<Integer, HashMap<Integer, Integer>> readCount; // t -> x -> cnt(t,x)

	public HashSet<Integer> relevantThreadsOrLocks;
	public HashSet<Integer> relevantWrites;
	public HashMap<Integer, HashSet<Integer>> relevantReads; // t -> Set(relevant reads)

	public Boolean hasRace;
	public HashMap<T, Integer> parents; // For parents(p) = #of occurrences of this as a child node of p.
	public int topologicalIndex;

    protected SymbolZip(String n) {
		super(n);
		this.name = n;
	}

	public String getName(){
		return this.name;
	}

	protected abstract void countThreadsOrLocks();
	protected abstract void countVariables();
	
	protected void countObjects() {
		this.countThreadsOrLocks();
		this.countVariables();
	}

	public boolean Race(){
		return this.hasRace;
	}

	protected void init() {
		threadOrLockCount = null;
		writeCount = null;
		readCount = null;

		relevantWrites = null;
		relevantReads = null;
		relevantThreadsOrLocks = null;

		hasRace = null;
		parents = null;
		topologicalIndex = -1;
	}

	public abstract void computeData();

	private void computeRelevantVariables(){
		this.relevantWrites = new HashSet<Integer> ();
		for (HashMap.Entry<Integer, Integer> entry : this.writeCount.entrySet()){
			int x = entry.getKey();
			for(T p : this.parents.keySet()){
				if(p.relevantWrites.contains(x)){
					this.relevantWrites.add(x);
					break;
				}
				if(p.writeCount.get(x) >= 2){
					this.relevantWrites.add(x);
					break;
				}
				
				for(int t: p.threadOrLockCount.keySet()){ // Here t could be a lock as well. But in the next line, this is going to be ruled out because the domain of threadReadCount is going to be restricted to threads 
					if(p.readCount.containsKey(t)){
						if(p.readCount.get(t).containsKey(x)){					
							if(p.readCount.get(t).get(x) >= 1){ // This is an over-approximation. "this" could be the only child that has a read event of x.
								
								boolean this_has_read_t_x = false;
								
								//Case-1. this has a read(t, x) for some t, and this occurs atleast twice in parent
								if(this.readCount.containsKey(t)){
									if(this.readCount.get(t).containsKey(x)){
										this_has_read_t_x = true;
										if(this.parents.get(p) >= 2){
											this.relevantWrites.add(x);
											break;
										}
										//Case-2. there is atleast one more sibling that has read(t,x) for some t, apart from me.
										else if(p.readCount.get(t).get(x) >= 2){
											this.relevantWrites.add(x);
											break;
										}

									}
								}
								//Case-3. this does not have a read(t,x) for any t, but there is a sibling (and thus a parent) that has.
								if(!this_has_read_t_x){
									if(p.readCount.get(t).get(x) >= 2){
										this.relevantWrites.add(x);
										break;
									}
								}
							}
						}
					}
				}
			}
		}
		
		this.relevantReads = new HashMap<Integer, HashSet<Integer>> ();
		for (HashMap.Entry<Integer, HashMap<Integer, Integer>> entry : this.readCount.entrySet()){
			int t = entry.getKey();
			HashMap<Integer, Integer> read_to_cnt = entry.getValue();			
			for(int x : read_to_cnt.keySet()){
				for(T p : this.parents.keySet()){
					if(p.relevantReads.containsKey(t)){
						if(p.relevantReads.get(t).contains(x)){
							if(!this.relevantReads.containsKey(t)){
								this.relevantReads.put(t, new HashSet<Integer> ());
							}
							this.relevantReads.get(t).add(x);
							break;
						}
					}
					if(p.writeCount.containsKey(x)){
						//Case-1. I write to x and my parent has 2 children that write to x.
						if(this.writeCount.containsKey(x)){
							if(p.writeCount.get(x) >= 2){
								if(!this.relevantReads.containsKey(t)){
									this.relevantReads.put(t, new HashSet<Integer> ());
								}
								this.relevantReads.get(t).add(x);
								break;
							}
						}
						//Case-2. I do not write to x, and there is one child of my parent that writes to x.
						else if(p.writeCount.get(x) >= 1){
							if(!this.relevantReads.containsKey(t)){
								this.relevantReads.put(t, new HashSet<Integer> ());
							}
							this.relevantReads.get(t).add(x);
							break;
						}
					}
				}
				
			}
		}
	}
	
	private void computeRelevantThreadsOrLocks(){
		this.relevantThreadsOrLocks = new HashSet<Integer> ();
		for (HashMap.Entry<Integer, Integer> entry : this.threadOrLockCount.entrySet()){
			int u = entry.getKey();
			for(T p : this.parents.keySet()){
				if(p.relevantThreadsOrLocks.contains(u)){
					this.relevantThreadsOrLocks.add(u);
					break;
				}
				if(p.threadOrLockCount.get(u) >= 2){
					this.relevantThreadsOrLocks.add(u);
					break;
				}
			}
		}
	}

	public void computeRelevantData(){
		computeRelevantVariables();
		computeRelevantThreadsOrLocks();
	}

	public void deleteCounts(){
		//Counts are not needed once all the relevant 
		//things (including those for intermediate non terminals) have been calculated
		this.threadOrLockCount = null;
//		this.writeCount = null;
//		this.readCount = null;
	}
}
